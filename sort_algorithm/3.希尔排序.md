## 希尔排序

- 算法流程：
  - 先将待排序表，分割成若干 形如L[i,i+d,i+2d,...,i+kd]的“特殊“子表,对各个子表分别进行直接插入排序。
  - 缩小增量d，重复上述过程，直到d=1
- 性能：
  - 空间复杂度：O(1)
  - 时间复杂度：未知，但是优于直接插入排序
  - 稳定性：不稳定
  - 适用性：仅可用于顺序表
- 高频题型：
  - 给出增量序列，分析每一趟排序后的状态

```c
//希尔排序
void ShellSort(int A[],int n){
int d, i, j;
//A[0]只是暂存单元，不是哨兵，当j<=0时，插入位置已到
for(d= n/2; d>=1; d=d/2)
    for(i=d+1; i<=n;++i)
        if(A[i]<A[i-d]){
            A[O]=A[i];
            for(j= i-d; j>0 && A[0]<A[j]; j-=d)
                A[j+d]=A[j];

            A[j+d]=A[0];
        }
```

![Img](E:/work_Space/C/c/c_lan/sort_algorithm/希尔排序.png)

