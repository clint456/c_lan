## 指针是什么：

> - 地址：
>   - 位置信息
>   - 类型信息 

区别：存储单元的内容

`对变量的访问都是通过地址进行`

## 指针变量是什么：

> - 存放地址的变量
## 指针变量作为函数参数
`注意：`
- c语言中实参变量和形参变量之间的数据传递是单向传递的“值传递”
- 而指针作为函数参数时，同样要遵循“单向值传递的规则`!
## 指针指向数组:

### 指针运算
`如： int a[10];
int  *p = a;`
> 指针法 ==> 下标法
> - p ==> &a[0]
> - p+1 ==> &a[1] 
> - *p ===> a[0] 
> - *(p+1) ===> a[1]
> - p2-p1 ===> 2 
```c
int *p1 = a[3];
int *p2 = a[5]
printf("%d\n",p2-p1);
// ==> p2 - p1 ==> 2
//表示元素之间差2个元素
```

`注意：两个地址不能相加，如p1+p2没有意义`

### 引用数组元素的三种方法
- 1.下标法
`a[i]`
- 2.通过数组名计算数组元素的地址，找出元素的值
- `{1.2.效率相同，都是转化为*(a+i)}`
- 3.使用指针变量指向数组元素`(效率最高，不必每次都重新计算地址)`

`注意：`
- 不能将数组名a++，因为本质上：数组名是一个常量地址，不可以改变；
- 而指针变量可以进行运算，因为它是一个变量`

### 数组的高级用法：
- p[i]是什么
```c
p[1] == *(p+1) = a[0+1] == a[1]
```
- **指针引用数组元素方法总结**

```c
#include <stdio.h>

int main(int argc, char const *argv[])
{
    /* code */
    int a[100] = {1,2,3,4,5,6,7,8,9,10};
    int *p = &a[0]; //初始化
    //int *p = a

    //1.p++
    p++;
    printf("p++: %d\n",*p);
    // == 》 2

    p = a;
    //2. *p++  == *(p++)  
    //*和++优先级级相同，自右向左运算
    printf("*p++: %d\n",*p++);
    printf("*p: %d\n",*p);
    p = a;
    printf("*++p:%d\n",*(++p));
    //注意：++p 和 p++ 的区别

    p=a;
    //3.*(p++) and *(p++) 
    //这里注意自增自减符的特性即可

    //4.++(*p)
    p++; 
    printf("*p: %d\n",*p);
    printf("++(*p):%d\n",++(*p));
    //这里注意是将数组中的值自增，而不是p移动到下一个数组元素

    //5. *(++p) == a[i++]     *(p--) == a[i--]     *(--p) == a[--i]
    //p先自增或自减运算，在进行取值*运算

    p = a;
    //输出数组的100个元素
    //方法一
    printf("输出数组的100个元素【方法一】:\n");
    while (p<a+100)
    {
        printf("%d",*p++);
    }
    printf("\n");


    p=a;
    //方法二
    printf("输出数组的100个元素【方法二】：\n");
    while(p<a+100)
    {
        printf("%d",*p);
        p++;
    }
    printf("\n");

    return 0;
}

```

### 使用数组名作为函数参数

### 通过指针引用多维数组
#### 1.多维数组元素的地址
```c
int main(int argc, char const *argv[])
{
    int a[3][4] = {1,3,5,7,9,11,13,15,17,19,21,23};
    printf("a: %d,*a: %d\n",a,*a); 
    //a: 0行起始地址 *a: 0行0列元素地址  
    printf("a[0]: %d,*(a+0): %d\n",a[0],*(a+0));
    //a[0]: *(a+0): 0行0列元素地址
    printf("&a[0]: %d,&a[0][0]:%d\n",&a[0],&a[0][0]);
    //&a[0]: 0行起始地址 &a[0][0]： 0行0列元素地址

    printf("a[1]: %d, a+1: %d\n",a[1],a+1);
    //a[1]: 1行0列元素地址  a+1: 1行起始地址
    printf("&a[1][0]： %d,*(a+1)+0： %d\n",&a[1][0],*(a+1)+0);
    //第1行0列元素地址
    printf("a[2]: %d,*(a+2):%d\n",a[2],*(a+2));
    //第2行0元素地址

    printf("a[1][0]: %d,*(*(a+1)+0): %d",a[1][0],*(*(a+1)+0));
    //1行0列元素的值


    return 0;
}
```
```
a: 1870657792,*a: 1870657792
a[0]: 1870657792,*(a+0): 1870657792
&a[0]: 1870657792,&a[0][0]:1870657792
a[1]: 1870657808, a+1: 1870657808
&a[1][0]： 1870657808,*(a+1)+0： 1870657808
a[2]: 1870657824,*(a+2):1870657824
a[1][0]: 9,*(*(a+1)+0): 9
```
#### tips：**在二维数组a[3][4]中**
- `a[0] 类型为int*型（指向整型变量`
- `a 类型为int (*p)[4] (指向含有4个元素的一维数组)`

#### 2.指向多为数组元素的指针变量
- 利用二维数组的顺序存储方式   a[i][j] ===> a + (i*m +j)  ===》基类型: int*
- 利用指向包含m个元素的一维数组 int (*p)[m]  ===>基类型：一维数组 

#### 3.指向数组的指针作为函数参数