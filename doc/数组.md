## 一维数组
### 定义：
`类型说明 数组名[常量表达式]`
---
> **要求：**
> - 遵循标识符命名规则
> - 下标是从`常量表达式` ,从0开始
> - 常量表达式字面意思，但是千万注意`不能是变量`
---

### 引用：
`数组名[下标]`
>- 下标：可以是`整型常量表达式` 或者 `整型表达式`

---
### 初始化：
```c
//1.定义数组对全部数组赋值
int a[5]={0,1,2,3,4};

//2.只给数组一部分元素赋值
//给后面两个元素赋初值为0
int a[5] = {0,1,2};

//3.给数组全部赋值为0
int a[10] = {0};

//4.对于确定的元素，可以不指定数组的长度
int a[] = {0，1，2，3，4};
```
`Tips:`
`对于仅指定了数组长度的，但未初始化值的数组`
>  - 普通数组： 对于数组的元素置为0
>  - 字符型数组： 初始化为'\0'
>  - 指针型数组： 初始化为NULL(即空指针)
---

## 二维数组
### 定义：
`类型说明符 数组名[常量表达式][常量表达式]`
> - 二维数组中元素排序的顺序是`按行排序`
> - 矩阵形式表示二维数组是逻辑上的概念，`在内存中,各个元素连续、线性存放的`

### 引用：
`数组名[下标][下标]`
- 下标上整形表达式
> - 下标的值应在已定义的数组大小范围内（出现数组越界，数值未知）

### 初始化：
```
//1.手动分行赋值
int a[3][4]={ {1,2,3},{4,5,6},{7,8,9}};

//2.直接赋值（系统自动分行）
int a[3][4]={1,2,3,4,5,6,7,8,9};

//3.部分赋值
int a[3][4] = { {1},{5},{9}};

//4.对每行指定元素赋值
int a[3][4] = { {1},{0,6},{0,0,11}};

//5.对某行元素进行赋值
int a[3][4] = { {1},{5,6}};

//6.指定某行不赋值
int a[3][4] = { {1},{},{9}};

//7.省略一维长度(二维长度不能省略)
int a[][4] = {1,2,3,4,5,6,7,8,9,10,11,12};

//8.最懒的写法
int a[][4] ={ {1,2,3},{},{0,10}};
```
### 用例p152
```c

void two_dimension_swap_r_c()
{
    int a[2][3] = { {1,2,3},{4,5,6}};
    int b[3][2],i,j;

    printf("array a:\n");
    for(i=0;i<=1;i++)
    {
        for(j=0;j<=2;j++)
        {
            printf("%5d",a[i][j]);
            b[j][i] = a[i][j];
        }
        printf("\n");
        }
        printf("array b:\n");
        for(i=0;i<=2;i++)
        {
            for(j=0;j<=1;j++) printf("%5d",b[i][j]);
        printf("\n");
        }
        
    
}
```

---
## 字符数组
`c99标准中 --- 字符类型 被归纳为 整形类型`
### 定义： 
``` c
char c[10];
c[0] = 'I'
```

### 初始化：
> - 初始化个数 大于 数组长度 ---> `语法错误`
> - 初始化个数 小于 数组长度 ---> `自动补\0`

```c
//1.普通版本
char c[10] = {'c',' ','p','o'};

//2.省略数组长度
char c[] ={'c','p','o'};
```
### 引用：
```c
//实例：输出一个菱形图
void out_rhombus()
{
    char diamond[][5] = {
        {' ',' ','*'},
        {' ','*',' ','*'},
        {'*',' ',' ',' ','*'},
        {' ','*',' ','*'},
        {' ',' ','*'}
        };

        int i,j;
        for(i=0;i<5;i++)
        {
            for(j=0;j<5;j++)
                printf("%c",diamond[i][j]);
            printf("\n");
        }
        
}
```

## 字符串：
> - 本质是：一维数组
> - 区别：字符数组存储`字符串`时，会自动加上一个`\0`，代表结束
> - printf函数：通过检测`\0`来结束输出

### 字符串常量使字符数组初始化
```c
//形式1
char c[] = {"you are foolish"};

//形式2
char c[] = "you are foolish";
```

### 字符数组和字符串的区别：
> - 字符数组：不要求最后一个字符时`\0` --- 合法
> - 字符串： 自动添加`\0` 


## 字符数组的输入输出：

> - 逐个字符输出 `%c`
> - 将整个字符串一次性输出 `%s`

### **TIPS:**
>
>  - `printf()`
>
>    - 输出不包括结束符`\0` ，并且只输出到`\0`
>    - 如果包含多个`\0` ，按照第一个为准
>
>  - `scanf()`
>
>    - 输入项c --[已定义的字符数组名] `应短于已经定义的字符数组的长度`
>
>    - 如果利用scanf输入多个字符串，应该用`空格`分开
>
>      ```c
>      char str1[5],str2[5],str3[5];
>      scanf("%s%s%s",str1,str2,str3);
>      
>      //输入===> How are you?
>      ```
>
>    - `空格：`系统会默认为分隔符
>

####include <string.h>

> - puts(字符数组)：
    > int puts(const char *str)
    > 如果成功，则返回非负值。如果出错，函数返回 EOF。
>   - puts输出自动将`\0`替换为`\n`
>   
> - gets(字符数组):
    > char *gets(char *str)
    > 该函数成功时返回 str，出错或文件结束时返回 NULL，同时没有读取任何字符。
>   - ```c
>      get(str);
>      //输入 ===> Computer
>      //tips:这里输入的9个字符，要算上\0	
>      ```
>      
>    - puts & gets 都只能输出、输入一个字符串！！
>    
>  - strcat(字符数组1，`已经赋值的字符数组2/字符串`)
    > cahr * strcat(char *dest,const char *src)
>  
>    - 【catenate】：vt.形成锁链
>    - str2 ===合并到===》 str1
>    - 这里注意str1的长度要够，不要出现数组越界
>  
>  - strcpy(字符数组1，`已经赋值的字符数组2/字符串`)
    > char* strcpy(char* destination, const char* source);
>  
>    - ``` c
>      char str[10],str2[] = "China";
>      strcpy(str1,str2);
>      // str2 ===合并===》 str1
>      ```
>  
>      - tips：
>        - 字符数组1：必须是数组名形式
>        - 字符串2：可以是字符数名，也可以是一个字符串常量
>        - 不能将   `一个字符串常量或字符数组`   ==直接给 ===> `一个字符数组` [字符数组名 -- 一个地址常量，不能改变其值] ， 只能用strcpy来复制
>
>  - strncpy(str1，`已经赋值的字符数组2/字符串`，num)
    > char * strncpy ( char * destination, const char * source, size_t num );
>
>    - num：将str2前num个字符复制到str1中
>  
>  - strcmp(`字符串1`，`字符串2`)
    > int strcmp (const char* str1, const char* str2);
>  
>    - 从左到右进行`逐个字符比较`
>      - str1 = str2 ===> 0
>      - str1 > str2 ===> 一个正整数
>      - str1 < str2 ===> 一个负整数
>
>  - strlen（字符数组）
>
>    - 返回长度不包括`\0`
>
>  - strlwr(字符串)
    > char *strlwr(char *str);
>    - LoWeRcase：转换为小写
>
>  - strupr（字符串）
    > char *strupr(char *str);
>    - UPpRcase：转换为大写



